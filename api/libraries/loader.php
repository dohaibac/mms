<?php
 defined('LIBS_PATH') or die; abstract class JLoader { protected static $classes = array(); protected static $imported = array(); protected static $prefixes = array(); protected static $classAliases = array(); protected static $namespaces = array(); public static function discover($classPrefix, $parentPath, $force = true, $recurse = false) { try { if ($recurse) { $iterator = new RecursiveIteratorIterator( new RecursiveDirectoryIterator($parentPath), RecursiveIteratorIterator::SELF_FIRST ); } else { $iterator = new DirectoryIterator($parentPath); } foreach ($iterator as $file) { $fileName = $file->getFilename(); if ($file->isFile() && substr($fileName, strrpos($fileName, '.') + 1) == 'php') { $class = strtolower($classPrefix . preg_replace('#\.php$#', '', $fileName)); if (empty(self::$classes[$class]) || $force) { self::register($class, $file->getPath() . '/' . $fileName); } } } } catch (UnexpectedValueException $e) { } } public static function getClassList() { return self::$classes; } public static function getNamespaces() { return self::$namespaces; } public static function import($key, $base = null) { if (!isset(self::$imported[$key])) { $success = false; $parts = explode('.', $key); $class = array_pop($parts); $base = (!empty($base)) ? $base : __DIR__; $path = str_replace('.', DIRECTORY_SEPARATOR, $key); if ($class == 'helper') { $class = ucfirst(array_pop($parts)) . ucfirst($class); } else { $class = ucfirst($class); } if (strpos($path, 'core') === 0) { $class = 'J' . $class; if (is_file($base . '/' . $path . '.php')) { self::$classes[strtolower($class)] = $base . '/' . $path . '.php'; $success = true; } } else { if (is_file($base . '/' . $path . '.php')) { $success = (bool) include_once $base . '/' . $path . '.php'; } } self::$imported[$key] = $success; } return self::$imported[$key]; } public static function load($class) { $class = strtolower($class); if (class_exists($class, false)) { return true; } if (isset(self::$classes[$class])) { include_once self::$classes[$class]; return true; } return false; } public static function register($class, $path, $force = true) { $class = strtolower($class); if (!empty($class) && is_file($path)) { if (empty(self::$classes[$class]) || $force) { self::$classes[$class] = $path; } } } public static function registerPrefix($prefix, $path, $reset = false, $prepend = false) { if (!file_exists($path)) { throw new RuntimeException('Library path ' . $path . ' cannot be found.', 500); } if (!isset(self::$prefixes[$prefix]) || $reset) { self::$prefixes[$prefix] = array($path); } else { if ($prepend) { array_unshift(self::$prefixes[$prefix], $path); } else { self::$prefixes[$prefix][] = $path; } } } public static function registerAlias($alias, $original) { if (!isset(self::$classAliases[$alias])) { self::$classAliases[$alias] = $original; return true; } return false; } public static function registerNamespace($namespace, $path, $reset = false, $prepend = false) { if (!file_exists($path)) { throw new RuntimeException('Library path ' . $path . ' cannot be found.', 500); } if (!isset(self::$namespaces[$namespace]) || $reset) { self::$namespaces[$namespace] = array($path); } else { if ($prepend) { array_unshift(self::$namespaces[$namespace], $path); } else { self::$namespaces[$namespace][] = $path; } } } public static function setup($enablePsr = true, $enablePrefixes = true, $enableClasses = true) { if ($enableClasses) { spl_autoload_register(array('JLoader', 'load')); } if ($enablePrefixes) { self::registerPrefix('J', LIBS_PATH . ''); spl_autoload_register(array('JLoader', '_autoload')); } if ($enablePsr) { spl_autoload_register(array('JLoader', 'loadByPsr0')); spl_autoload_register(array('JLoader', 'loadByAlias')); } } public static function loadByPsr0($class) { if ($class[0] == '\\') { $class = substr($class, 1); } $pos = strrpos($class, '\\'); if ($pos !== false) { $classPath = str_replace('\\', DIRECTORY_SEPARATOR, substr($class, 0, $pos)) . DIRECTORY_SEPARATOR; $className = substr($class, $pos + 1); } else { $classPath = null; $className = $class; } $classPath .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; foreach (self::$namespaces as $ns => $paths) { if (strpos($class, $ns) === 0) { foreach ($paths as $path) { $classFilePath = $path . DIRECTORY_SEPARATOR . $classPath; if (file_exists($classFilePath) && !class_exists($class, false)) { return (bool) include_once $classFilePath; } } } } return false; } public static function loadByAlias($class) { if ($class[0] == '\\') { $class = substr($class, 1); } if (isset(self::$classAliases[$class])) { class_alias(self::$classAliases[$class], $class); } } private static function _autoload($class) { foreach (self::$prefixes as $prefix => $lookup) { $chr = strlen($prefix) < strlen($class) ? $class[strlen($prefix)] : 0; if (strpos($class, $prefix) === 0 && ($chr === strtoupper($chr))) { return self::_load(substr($class, strlen($prefix)), $lookup); } } return false; } private static function _load($class, $lookup) { $parts = preg_split('/(?<=[a-z0-9])(?=[A-Z])/x', $class); $parts = (count($parts) === 1) ? array($parts[0], $parts[0]) : $parts; foreach ($lookup as $base) { $path = $base . '/' . implode('/', array_map('strtolower', $parts)) . '.php'; if (file_exists($path)) { return include $path; } } return false; } } function jimport($path) { return JLoader::import($path); }