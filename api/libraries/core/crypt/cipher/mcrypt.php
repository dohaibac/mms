<?php
 defined('LIBS_PATH') or die; abstract class JCryptCipherMcrypt implements JCryptCipher { protected $type; protected $mode; protected $keyType; public function __construct() { if (!is_callable('mcrypt_encrypt')) { throw new RuntimeException('The mcrypt extension is not available.'); } } public function decrypt($data, JCryptKey $key) { if ($key->type != $this->keyType) { throw new InvalidArgumentException('Invalid key of type: ' . $key->type . '.  Expected ' . $this->keyType . '.'); } $decrypted = trim(mcrypt_decrypt($this->type, $key->private, $data, $this->mode, $key->public)); return $decrypted; } public function encrypt($data, JCryptKey $key) { if ($key->type != $this->keyType) { throw new InvalidArgumentException('Invalid key of type: ' . $key->type . '.  Expected ' . $this->keyType . '.'); } $encrypted = mcrypt_encrypt($this->type, $key->private, $data, $this->mode, $key->public); return $encrypted; } public function generateKey(array $options = array()) { $key = new JCryptKey($this->keyType); $key->public = mcrypt_create_iv(mcrypt_get_iv_size($this->type, $this->mode)); $salt = (isset($options['salt'])) ? $options['salt'] : substr(pack("h*", md5(JCrypt::genRandomBytes())), 0, 16); if (!isset($options['password'])) { throw new InvalidArgumentException('Password is not set.'); } $key->private = $this->pbkdf2($options['password'], $salt, mcrypt_get_key_size($this->type, $this->mode)); return $key; } public function pbkdf2($p, $s, $kl, $c = 10000, $a = 'sha256') { $hl = strlen(hash($a, null, true)); $kb = ceil($kl / $hl); $dk = ''; for ($block = 1; $block <= $kb; $block++) { $ib = $b = hash_hmac($a, $s . pack('N', $block), $p, true); for ($i = 1; $i < $c; $i++) { $ib ^= ($b = hash_hmac($a, $b, $p, true)); } $dk .= $ib; } return substr($dk, 0, $kl); } }