<?php
 defined('LIBS_PATH') or die; class JCrypt { private $_cipher; private $_key; public function __construct(JCryptCipher $cipher = null, JCryptKey $key = null) { $this->_key = $key; $this->_cipher = isset($cipher) ? $cipher : new JCryptCipherSimple; } public function decrypt($data) { try { return $this->_cipher->decrypt($data, $this->_key); } catch (InvalidArgumentException $e) { return false; } } public function encrypt($data) { return $this->_cipher->encrypt($data, $this->_key); } public function generateKey(array $options = array()) { return $this->_cipher->generateKey($options); } public function setKey(JCryptKey $key) { $this->_key = $key; return $this; } public static function genRandomBytes($length = 16) { $length = (int) $length; $sslStr = ''; if (function_exists('openssl_random_pseudo_bytes')) { $sslStr = openssl_random_pseudo_bytes($length, $strong); if ($strong) { return $sslStr; } } $bitsPerRound = 2; $maxTimeMicro = 400; $shaHashLength = 20; $randomStr = ''; $total = $length; $urandom = false; $handle = null; if (function_exists('stream_set_read_buffer') && @is_readable('/dev/urandom')) { $handle = @fopen('/dev/urandom', 'rb'); if ($handle) { $urandom = true; } } while ($length > strlen($randomStr)) { $bytes = ($total > $shaHashLength)? $shaHashLength : $total; $total -= $bytes; $entropy = rand() . uniqid(mt_rand(), true) . $sslStr; $entropy .= implode('', @fstat(fopen(__FILE__, 'r'))); $entropy .= memory_get_usage(); $sslStr = ''; if ($urandom) { stream_set_read_buffer($handle, 0); $entropy .= @fread($handle, $bytes); } else { $samples = 3; $duration = 0; for ($pass = 0; $pass < $samples; ++$pass) { $microStart = microtime(true) * 1000000; $hash = sha1(mt_rand(), true); for ($count = 0; $count < 50; ++$count) { $hash = sha1($hash, true); } $microEnd = microtime(true) * 1000000; $entropy .= $microStart . $microEnd; if ($microStart >= $microEnd) { $microEnd += 1000000; } $duration += $microEnd - $microStart; } $duration = $duration / $samples; $rounds = (int) (($maxTimeMicro / $duration) * 50); $iter = $bytes * (int) ceil(8 / $bitsPerRound); for ($pass = 0; $pass < $iter; ++$pass) { $microStart = microtime(true); $hash = sha1(mt_rand(), true); for ($count = 0; $count < $rounds; ++$count) { $hash = sha1($hash, true); } $entropy .= $microStart . microtime(true); } } $randomStr .= sha1($entropy, true); } if ($urandom) { @fclose($handle); } return substr($randomStr, 0, $length); } public static function timingSafeCompare($known, $unknown) { $known .= chr(0); $unknown .= chr(0); $knownLength = strlen($known); $unknownLength = strlen($unknown); $result = $knownLength - $unknownLength; for ($i = 0; $i < $unknownLength; $i++) { $result |= (ord($known[$i % $knownLength]) ^ ord($unknown[$i])); } return $result === 0; } public static function hasStrongPasswordSupport() { if (!defined('PASSWORD_DEFAULT')) { include_once PATH_ROOT . '/libraries/compat/password/lib/password.php'; } return true; } }