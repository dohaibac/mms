<?php
 defined('LIBS_PATH') or die; class JStringInflector { private static $_instance; private $_rules = array( 'singular' => array( '/(matr)ices$/i' => '\1ix', '/(vert|ind)ices$/i' => '\1ex', '/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|viri?)i$/i' => '\1us', '/([ftw]ax)es/i' => '\1', '/(cris|ax|test)es$/i' => '\1is', '/(shoe|slave)s$/i' => '\1', '/(o)es$/i' => '\1', '/([^aeiouy]|qu)ies$/i' => '\1y', '/$1ses$/i' => '\s', '/ses$/i' => '\s', '/eaus$/' => 'eau', '/^(.*us)$/' => '\\1', '/s$/i' => '', ), 'plural' => array( '/([m|l])ouse$/i' => '\1ice', '/(matr|vert|ind)(ix|ex)$/i' => '\1ices', '/(x|ch|ss|sh)$/i' => '\1es', '/([^aeiouy]|qu)y$/i' => '\1ies', '/([^aeiouy]|qu)ies$/i' => '\1y', '/(?:([^f])fe|([lr])f)$/i' => '\1\2ves', '/sis$/i' => 'ses', '/([ti])um$/i' => '\1a', '/(buffal|tomat)o$/i' => '\1\2oes', '/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|vir)us$/i' => '\1i', '/us$/i' => 'uses', '/(ax|cris|test)is$/i' => '\1es', '/s$/i' => 's', '/$/' => 's', ), 'countable' => array( 'id', 'hits', 'clicks', ), ); private $_cache = array(); protected function __construct() { $this ->addWord('deer') ->addWord('moose') ->addWord('sheep') ->addWord('bison') ->addWord('salmon') ->addWord('pike') ->addWord('trout') ->addWord('fish') ->addWord('swine') ->addWord('alias', 'aliases') ->addWord('bus', 'buses') ->addWord('foot', 'feet') ->addWord('goose', 'geese') ->addWord('hive', 'hives') ->addWord('louse', 'lice') ->addWord('man', 'men') ->addWord('mouse', 'mice') ->addWord('ox', 'oxen') ->addWord('quiz', 'quizes') ->addWord('status', 'statuses') ->addWord('tooth', 'teeth') ->addWord('woman', 'women'); } private function _addRule($data, $ruleType) { if (is_string($data)) { $data = array($data); } elseif (!is_array($data)) { throw new InvalidArgumentException('Invalid inflector rule data.'); } foreach ($data as $rule) { array_push($this->_rules[$ruleType], (string) $rule); } } private function _getCachedPlural($singular) { $singular = JString::strtolower($singular); if (isset($this->_cache[$singular])) { return $this->_cache[$singular]; } return false; } private function _getCachedSingular($plural) { $plural = JString::strtolower($plural); return array_search($plural, $this->_cache); } private function _matchRegexRule($word, $ruleType) { foreach ($this->_rules[$ruleType] as $regex => $replacement) { $matches = 0; $matchedWord = preg_replace($regex, $replacement, $word, -1, $matches); if ($matches > 0) { return $matchedWord; } } return false; } private function _setCache($singular, $plural = null) { $singular = JString::strtolower($singular); if ($plural === null) { $plural = $singular; } else { $plural = JString::strtolower($plural); } $this->_cache[$singular] = $plural; } public function addCountableRule($data) { $this->_addRule($data, 'countable'); return $this; } public function addWord($singular, $plural =null) { $this->_setCache($singular, $plural); return $this; } public function addPluraliseRule($data) { $this->_addRule($data, 'plural'); return $this; } public function addSingulariseRule($data) { $this->_addRule($data, 'singular'); return $this; } public static function getInstance($new = false) { if ($new) { return new static; } elseif (!is_object(self::$_instance)) { self::$_instance = new static; } return self::$_instance; } public function isCountable($word) { return (boolean) in_array($word, $this->_rules['countable']); } public function isPlural($word) { $inflection = $this->_getCachedSingular($word); if ($inflection !== false) { return true; } return $this->toPlural($this->toSingular($word)) == $word; } public function isSingular($word) { $inflection = $this->_getCachedPlural($word); if ($inflection !== false) { return true; } return $this->toSingular($this->toPlural($word)) == $word; } public function toPlural($word) { $cache = $this->_getCachedPlural($word); if ($cache !== false) { return $cache; } if ($this->_getCachedSingular($word)) { return false; } $inflected = $this->_matchRegexRule($word, 'plural'); if ($inflected !== false) { $this->_setCache($word, $inflected); return $inflected; } return false; } public function toSingular($word) { $cache = $this->_getCachedSingular($word); if ($cache !== false) { return $cache; } if ($this->_getCachedPlural($word)) { return false; } $inflected = $this->_matchRegexRule($word, 'singular'); if ($inflected !== false) { $this->_setCache($inflected, $word); return $inflected; } return false; } }